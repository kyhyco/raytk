> Like 3D but flatter!

So far, what we've been discussing have been operators that deal with 3D coordinates.

But ROPs can also work with different types of coordinates:

- 1D, a.k.a. `float`: We'll cover this in the [Fields Part 2](https://www.notion.so/Section-Fields-Part-2-6e222616e7a2489bbe72484c8fd3d338) and [Functions](https://www.notion.so/Section-Functions-3a2306da7d7d4d9d9ca167deb931517a) sections.
- 2D, a.k.a. `vec2`: That's what this section is about!
- 3D, a.k.a. `vec3`: This is what we've been discussing so far.

# Rendering 2D

There are a variety of different ways to use 2D coordinates, but the most straightforward is with the `render2D`  Output operator.

It's similar to `raymarchRender3D` in terms of how it uses its inputs to build and run a shader. But the way that it uses the inputs is much simpler.

For each pixel in the rendering, it asks its input what color it should be.

There's a bit more to it than that, but essentially that's what it comes down to.

It supports a few different types of inputs, but all of them must use 2D coordinates.

- A vector field input is asked for a value for some 2D position, and it uses the answer as the color (RGBA).
- A float field input is similar, but it takes that single value and uses for all channels (RGBA).
- SDF input is handled a bit differently than it is with `raymarchRender3D`.

# SDFs in 2D

Remember that the answer that SDF operators produce is the distance to the nearest surface (and some properties of that surface, which aren't used in 2D rendering).

When you connect an SDF to a `render2D`, all it does with the result is take the distance value and use it for all channels (RGBA).

This means that directly on the surface, the result will be 0, and it will increase the further that it gets from the surface (when on the outside of the shape). The inside values are negative. But when you look at those in a TOP, you can't actually see negative values so it just shows up as black. Values larger than 1 will just look white.

Try creating a `circleSdf2d` and connecting it to a `render2D`. The result will be a circular gradient.

There are sometimes reasons to use this kind of rendering, but from a visual perspective, it isn't that useful.

For example, you can use a 2D SDF to create complex gradients that you can't make with a `Ramp TOP`.

## Coloration and visualization

If you want to see a more useful visualization of the SDFs in 2D, you can use the `colorizeSdf2d` operator between the SDF and the `render2D`.  It uses a striped pattern to visualize the inside and outside of the shape and the space around it.

The `colorizeSdf2d` operator is in the "Materials" category, though strictly speaking it isn't a "material" in the sense of the other materials we've used previously like `basicMat`. But it does serve a similar purpose.

You may be wondering why you can't just use the same materials that are used for raymarching. The reason is that those materials are all about the behavior of rays of light. And in `render2D` there are no rays at all.

# Coordinates in 2D rendering

When `render2D` is asking its input for a color (or something it can convert to a color), it needs to specify what the coordinates are. There are a few different ways it can do that.

In the simplest option, it can just a normalized `0 .. 1` range for both X and Y, stretched to fill the rendering in both dimensions.

Or it can use the aspect ratio to correct the scaling of the two dimensions so they're at the same scale as each other.

It can also center the coordinates on `0, 0`, so it would use a range from `-0.5 .. 0.5`. 

If you want total control of the coordinates that it uses for each pixel, you can also provide it with a UV map in a `TOP`, and it will use the R and G channels for the coordinates for each pixel.

Later on we'll get into some clever ways you can use the UV map for all kinds of interesting things..

# Working in 2D

Now that we've discussed how `render2D` uses its input, we're going to discuss the kinds of things you can and can't do in the 2D world.

Most of the transform-based filters, like `translate`, and `scale` can also work in 2D, they just ignore the Z settings.

The `rotate` operator also works, but it will only allow you to specify a single rotation setting, since there's only one axis you can rotate around.

Many of the operators that use reflection and repetition can also work in 2D, including `reflect`, `modulo1D`, `modulo2D`, and even `mirrorOctant`. But of not `modulo3D` as one might guess.

The best way to find out if a filter supports 2D is to try using it on some 2D SDFs or fields. If it doesn't support it, you'll see an error on the filter.

Most of the Combiners also work in 2D! You can't directly combine 2D and 3D SDFs, but there are some ways to use 2D SDFs in 3D scenes that we'll discuss later.

# ROPs as TOPs

You may have noticed that when using `render2D`, some types of ROPs are kind of behaving like TOPs, where they are working with 2D (UV) coordinates and generating values (colors) for each pixel.

If you use a `textureField`, followed by various transforms, followed by a `render2D`, you've just made a 2D video effect using ROPs!

You can use a `moduloPolar` to create a kaleidoscope effect!

Or use `bend` to, you know... bend! Try doing that in a TOP without writing a shader.

With the 2D SDF operators, you can create all kinds of complex shapes. If you use a `colorizeSdf2D` and set the two inner colors to the same value and the outer ones to the same value, you can produce filled-in shapes, or use the edge settings to create outlines.

While RayTK wasn't originally designed with this kind of use in mind, it has ended up as a fairly useful 2D shader system.

## Patterns

The "Pattern" operators are float / vector fields that are designed for that kind of use. They use 2D coordinates, and produce various types of infinitely tileable patterns.

For example, the `hexagonalGridPattern` makes, as one might expect, a hexagonal grid!

There are a variety of other patterns available.

Because they use 2D coordinates and produce float or vector answers, you can just connect them directly to a `render2D` to see what they look like.

You may be wondering why you would want to use pattern ROPs instead of just using TOPs and passing in images using `textureField`. Here are some advantages:

- Pattern ROPs are exactly as high resolution as they need to be to render the resulting image. Because they are evaluated on demand, whereever the shader asks for a value, it will provide the value for that exact position, no matter how zoomed in it is.
    - If you have a TOP that's 1920x1080, even if it's being produced by another shader, it will only ever have a fixed level of detail when you pass it over to the `textureField`.
- They are infinite along both axes.
    - Unless you carefully design your TOP to tile perfectly, the pattern won't repeat seamlessly if something goes outside the 0..1 UV range.
    - Pattern ROPs can be used any any coordinates and will tile seamlessly anywhere that they are checked by the shader.
- They integrate well into existing scenes without having to have a separate shader / TOP chain that that gets fed into the ROP scene.
    - Often this is an advantage but there are times when you actually do want to separate the work into multiple shaders, especially if you get fancy and have them running on different machines.

# From 2D to 3D

In addition to the purely 2D workflows, there are a number of different ways that you can use 2D SDFs and fields to produce or modify 3D shapes.

The `extrude` operator takes a 2D SDF, places it along one plane (e.g. XY or YZ) and then stretches it out along the axis perpendicular to the plane. It's sort of like a cookie-cutter where you can control the thickness of the dough and the 2D SDF is the shape of the cutter.

There's also the `revolve` operator, which takes a 2D SDF and spins it around an axis to create a rounded shape in 3D. It's equivalent to the `Revolve SOP`.

![https://iquilezles.org/www/articles/distfunctions/gfx49.png](https://iquilezles.org/www/articles/distfunctions/gfx49.png)

[https://iquilezles.org/www/articles/distfunctions/distfunctions.htm](https://iquilezles.org/www/articles/distfunctions/distfunctions.htm)

The `sweep` operator takes one 2D SDF and weeps it along the path of another 2D SDF that's on another plane.

It's like if you took two flat shapes, and put one on a table and turned the other one up on its side and moved it around the edge of the other shape.

[Shadertoy](https://www.shadertoy.com/view/MlyfRW)

## 2D Fields in 3D

2D patterns can be used as fields in a 3D context if they are passed through the `coordTo3D` operator, which lets you map them onto one of the planes (e.g. XY). You can then use that for things like offsetting using `transform`.

You can even take 2 different 2D patterns, apply one along one plane, and another perpendicular to that, and merge the two fields using `combineFields`.
